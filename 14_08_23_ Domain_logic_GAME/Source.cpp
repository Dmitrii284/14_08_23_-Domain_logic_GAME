/*
Доменная логика - модель программы
1. Проект системы классов
2.Схема взаимодействия
? Что хрянят
? Кто и как пользуется

+ Занятие 16.08.32 Фото Схемы карт
{
До этого числа сдать проект. Он допуск к устному экзамену.
21 вопросы
28 Оценки за все

sfml - Надо бтблиотеку для визуализации Игры. 
nuget - Это встроенный репозиторий библиотек (Но не самые свежие) oprn ssl 3.0- но версии их разные. (Надо сначала скомпилировать на Гит) - Это задача
}


СМОТРИ ФОТО 14.08.23
Задача Игра КОЛОДА КАРТ(мини казино)

Сначало Создаем 

1 Проект системы классов

Создаем классы 
Крупье- (Он сдает и ХРАНИТ КОЛОДУ( Просто так решили)
 -> Колода [] - 

Карты - 
 -> Карты[]

 Правила

Игра - Вид игры(Бура, Фараон, 21) ( Содержит правила) ( Она определяет как тасовать колоду, Какая карта бъет другую карту)
 -> Правила

Игрок - Персона
 -> Рука
 -> Управление(Как переходит к руке карта)

Поле - На котором идет игра ( Какие карты выкладываются на стол)

Колода - Что в колоде (Тут количество Пик  Количество Крести, Количество Шестерок. ( Колода которая подходит для игры)
 ->(value- rank)

Руки - Что на руках ( Представляет из себя Коллекцию карт)
 -> Карты[]
 

Вопрос где хранить колоду? (Надо выбрать Это Поле или это Крупье, Откуда добирать карты Игроку)- Определить к кому обратиться (А чтобы понять надо знать где 
храниться колода)

2 Схема взаимодействия( Что класс про себя знае  чем он является)
Определим кто с кем взаимодействует. ( Стараться избегать Наследования на начальной стадии, И так же вложенные классы) Потом может вызвать ПРОБЛЕМЫ!!!

 Игрок -> Рукой 
 Игрок -> Поле ( Игрок должен только видеть информацию на поле) ( Решение принимает на основе данных Поля)

 Игра -> Правила

 Колода -> Карты

 Крупье -> Колода
 Крупье -> Игра
 Кркпье -> Игрок( Он говорит ты Ходи) ( Не игрок решает что надо сделать ход) Каманда с наружи и это сделает Крупье. 
 Крупье -> Поле ( Должен пользоваться полем) 

 {
  Сделать заголовки Классов ( Определить Какую функцию мы вызываем? Какое действие мы вызываем?  Например Игрок -> Рукой  Для руки заказывает класс Игрока 
  В методы руки попадут те действия которые нужны Игроку)
  С позиции Колода Надо подумать Что надо знать про карту Чтобы ей пользоваться?
  С позиции Крупье Надо подумать какие знания надор знать .
  Каждая -> Это методы классов.
  }
  
  Все Методы класса в H Файле являются inline Если больше 5 строчек то выносим в cpp 
   В плане методов Крупье решает какой игрок ходит.
   Крупье и Игра ( Крупье решает что он вызывает такой то метод игры) SRP и Правило Диметры (Все действия этого класса пользовател 
   ( Метод должен  То что возвращать от игрока не нужно возвращать)
   В правилаx virtual и два 2 Родителя. 

   У игрока отсутсвует метод который возвращает (Ему просто сделать ход)
   У поля знание какие карты там находятся.
   У крупье поле которое возвращает информационный результат.
   Появяться доп вещи по мимо схемы dto - Это структуры которые пакетно хранят какуюто информацию (Структуры которые пакетно хранят инфу)

   DTO data tranfer object
   Структуры которые передают информацию между классами

   Задача Какие методы реализуют Наши Классы? 

   /////////////////////////////////////////////////////////////////
   Занятие 16.08.32
   Связи использования.
   Рассмотри концепцию как система классов будет использоваться с наружи.

   Допустим не Валидный ход картой . (Надо знать кто следит за этим и и откуда берет информацию для сравнения)

   Чем плохи связи использования между классами?
   Высокая связность кода
   Практически не возможно вносить изменения.
   Изменение в обном модуле будет тянуть изменеия в других объектах
  1.  Наследование
  2.  Использование - лучше отказаться на 100% (Это когда один класс знает о том что делает другой класс)
  3.  Композиция
  Эти связи по возможности не использовать
Чтобы менять компонент использования надо использовать АГРЕГАЦИЮ или КОМПОЗИЦИЮ
  И так класс ИГРА может быть лишним.(Ничего не мешает КРУПЬЕ знать ПРАВИЛА на прямую)
  Композиция(Незаштрихованные ромбики) - Тоесть наследоывание нам не поможет лучше использовать АГРЕГАЦИЮ. (Это заштрихованный ромбики)
  Сократим 
  Принцип DIP- Это агрегация способов управления ИГРОКОМ 
  Заштрихуем Ромбик класса УПРАВЛЕНИЕ - ИГРОК

  У нас есть ИГРОКИ  за СТОЛОМ (Есть информация о текущем положении за столом Какие карты)
  Настроим связи между Классами:
  1. ИГРОК - СТОЛ (за столом есть коллекция игроков) (Удалим стрелочку знания)
  2. КРУПЬЕ - Знает состав ИГРОКОВ кто должен ходить ОН ПЕРЕДАЕТ ХОД.
  3. СТОЛ - содержит всю инфу. и когда крупье передает ход игроку он может дать ссылку& на СТОЛ
  4. КРЕПЬЕ - ВСЕ ЗНАЕТ ОБОВСЕХ.
  Лучше поместить все классы в обертку(Чтобы вызывать к у них то что надо) Назовем его ФАСАДОМ
  Должен быть метод Старт.
  От ФАСАДА - Он должен знать Скоьлко игроков, Он Запуск , Количество игроков, кому когда ходить, Запустить игру)
  Шаблон ФАСАД - Работает в многопоточном приложении - Он может быть пошаговым.
  Шаблон НАБЛЮДАТЕЛЬ - работает с одним потоком. Он нужен для того чтобы время от времени знать какую то и нформацию
  И	ГРОК ПОЛУЧАЕТ ССЫЛКУ НА СТОЛ. (фОРМАЛИЗОВАТЬ Попробовать сделать ФАСАД ) Фасад это модель игры)




*/
